---
description: 
globs: 
---
---
description: Specific rules for writing javascript custom-elements
globs: **/custom-elements/**/*.js
---

# Custom Element Development Guidelines

These guidelines ensure that your custom elements are robust, maintainable, and easily styled. The instructions cover how to build custom elements without relying on Shadow DOM, favor event delegation, and split files to separate functional styles from aesthetic styling.

---

## 1. DOM Usage and Custom Element Construction

-   **Avoid Shadow DOM:**

    -   **Never** use Shadow DOM on a custom element.

-   **Prefer Light DOM:**

    -   Design custom elements to work with the Light DOM provided in the HTML.
    -   Leverage existing HTML elements and handle any missing elements gracefully.

-   **Minimal DOM Building:**

    -   **Rarely** create new DOM elements using `document.createElement` or by setting `innerHTML`.
    -   Instead, enhance and work with the HTML structure already in place.

-   **Event Bubbling:**
    -   Utilize event bubbling to simplify event management and component communication.

---

## 2. Event Handling Best Practices

-   **Listener Attachment:**

    -   Attach event listeners to the custom element itself rather than individual child elements.

-   **Event Delegation:**

    -   Use event delegation and bubbling to manage events from child elements.
    -   Always verify the event target and context before processing the event.

-   **Handler Binding:**
    -   **Avoid** binding event handlers in the constructor when event delegation is in use (the correct `this` context is already available).
    -   **Bind** event handlers only when they are required as callbacks or when not using delegation.

---

## 3. Enhancement Patterns

-   **Progressive Enhancement:**

    -   Enhance the existing HTML structure rather than replacing it entirely.
    -   Provide meaningful fallback behavior for when JavaScript is disabled.

-   **Custom Events and Data Attributes:**
    -   Emit custom events so that parent elements can respond to component state changes.
    -   Use data attributes to configure behavior while maintaining clear HTML semantics.

---

## 4. Reactive and State Management

-   **Reactive Patterns Over Initialization:**

    -   Favor reactive patterns that respond to events rather than a one-time DOM scan during initialization.
    -   Design custom elements as event-driven controllers rather than static configurators.

-   **DOM Reference Management:**
    -   Avoid storing DOM element references as instance properties unless absolutely necessary.
    -   Query the DOM when needed rather than caching elements preemptively.

---

## 5. Coupling and Dependencies

-   **Maintain Independence:**

    -   Ensure custom elements remain independent from the internal implementations of their children.
    -   Avoid tight coupling with the structure of child elements.

-   **Event and Attribute Driven:**
    -   React to events and attributes rather than manipulating child elements directly.
    -   Do not assume a fixed DOM structure during initialization.

---

## 6. Code Style Guidelines

-   **Constructor vs. Lifecycle Methods:**

    -   Keep constructors minimal.
    -   Use `connectedCallback` for setup tasks instead of the constructor.

-   **Default to Event Delegation:**

    -   Use event delegation as the default approach.
    -   Avoid binding unnecessary event handlers in the constructor when delegation is sufficient.

-   **Method Definitions:**
    -   Write event handlers as regular methods (not inline arrow functions) when they are used with event delegation, ensuring clarity and consistency.

---

## 7. File Structure and Asset Organization

To ensure a clean separation between functionality and aesthetics, each custom element must be split into three separate files:

-   **JavaScript Implementation:**

    -   **File Name:** `[custom-element-name].js`
    -   **Purpose:** Contains the custom element definition, registration, and associated business logic.

-   **Functional UX Styling:**

    -   **File Name:** `[custom-element-name].ux.css`
    -   **Purpose:** Provides the essential CSS for the custom elementâ€™s functionality and user experience. This file includes only the styles needed for proper operation and interaction, not for visual embellishments.

-   **Aesthetic Styling:**
    -   **File Name:** `[custom-element-name].style.css`
    -   **Purpose:** Contains aesthetic styling rules using custom properties. These styles reference values from an external `base-style.css` (which is not part of the custom element), allowing users to easily customize the visual appearance without modifying the functional CSS.

This file split ensures that:

-   The core functionality is preserved and maintained independently.
-   Developers or users can adjust the aesthetics (look and feel) without risking the functional behavior of the element.
